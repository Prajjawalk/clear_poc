## 11. Notification System

The notification system provides internal messaging capabilities for the EWAS platform. Through a unified notification management interface, the system handles real-time user notifications, alert distribution, task completion notices, and system status updates.

The framework integrates seamlessly with all system components, providing immediate in-app notifications.

### 11.1 Key concepts

#### Internal notification delivery
**Internal notifications** provide real-time user communication within the EWAS interface. These messages appear as in-app alerts, dashboard notifications, and status updates that keep users informed of system activity, task completions, and alert conditions without requiring email delivery.

The internal system supports multiple notification types including alerts, system messages, task updates, warnings, and errors. Each notification includes priority levels (low, medium, high, urgent) that determine display prominence and user attention requirements. Notifications maintain read status tracking and provide direct links to related system components when applicable.

The notification lifecycle includes creation, delivery, user acknowledgment, and automatic expiration based on notification type and age. System-generated notifications trigger automatically through Django signals, while manual notifications support administrative communication needs.

#### Notification preferences
**User preferences** control notification routing and delivery patterns through a comprehensive preference system. Users configure channel preferences (in-app, email), notification type filtering (alerts, tasks, system messages), and timing controls (immediate, hourly, daily, weekly).

The preference system includes quiet hours configuration to suppress non-urgent notifications during specified time periods, helping maintain work-life balance while preserving urgent communication pathways. Preference inheritance from role-based defaults ensures new users receive appropriate notification settings automatically.

### 11.2 Architecture

The notification system follows an event-driven architecture with centralized notification management and multiple delivery channels supporting both synchronous and asynchronous communication patterns.

#### Core components

**Notification Manager** serves as the central orchestrator for all notification activities. This component handles notification creation, routing decisions, delivery coordination, and status tracking across multiple channels. The manager implements priority-based queuing and batch processing for efficiency while maintaining real-time delivery for urgent notifications.

**Signal Integration** connects notification triggers to system events through Django's signal framework. Automatic notification generation responds to alert creation, task completion, user actions, and system events without requiring explicit integration code in other components.

**Email Service** manages external email delivery through configurable SMTP backends with template rendering, digest aggregation, and delivery tracking. The service includes retry logic for failed deliveries and maintains unsubscribe management for compliance.

**Preference Engine** evaluates user settings to determine notification routing, timing, and delivery methods. This component enforces quiet hours, frequency limits, and channel preferences while providing fallback delivery for critical notifications.

### 11.3 Data model

#### InternalNotification
The core model representing individual notification messages within the system.

| Field | Type | Description |
|-------|------|-------------|
| `user` | ForeignKey | Target user for notification delivery |
| `type` | CharField | Classification (alert, system, task, message, warning, error) |
| `priority` | CharField | Urgency level (low, medium, high, urgent) |
| `title` | CharField | Brief notification summary |
| `message` | TextField | Detailed notification content |
| `data` | JSONField | Additional structured context data |
| `link` | CharField | Optional URL for notification action |
| `icon` | CharField | UI icon identifier for visual presentation |
| `is_read` | BooleanField | User acknowledgment status |
| `read_at` | DateTimeField | Timestamp of user acknowledgment |
| `is_email_sent` | BooleanField | Email delivery tracking |
| `email_sent_at` | DateTimeField | Email delivery timestamp |
| `created_at` | DateTimeField | Notification creation time |
| `expires_at` | DateTimeField | Optional expiration for automatic cleanup |

#### NotificationPreference
User configuration for notification delivery channels and timing.

| Field | Type | Description |
|-------|------|-------------|
| `user` | OneToOneField | Associated user account |
| `email_enabled` | BooleanField | Enable email notification delivery |
| `in_app_enabled` | BooleanField | Enable in-application notifications |
| `alert_notifications` | BooleanField | Receive alert-related notifications |
| `task_notifications` | BooleanField | Receive task completion notifications |
| `system_notifications` | BooleanField | Receive system status notifications |
| `email_frequency` | CharField | Delivery timing (immediate, hourly, daily, weekly) |
| `quiet_hours_enabled` | BooleanField | Suppress non-urgent notifications during specified hours |
| `quiet_hours_start` | TimeField | Beginning of quiet period |
| `quiet_hours_end` | TimeField | End of quiet period |

### 11.4 Implementation

#### Notification creation workflow
The notification system implements a centralized creation workflow that handles both individual notifications and bulk messaging across user groups. The `NotificationManager` service provides the primary interface for notification creation, routing decisions, and delivery coordination.

**Creation process** begins with notification instantiation including recipient targeting, content generation, and priority assignment. The manager evaluates user preferences to determine delivery channels and timing, applying quiet hours restrictions and frequency controls as configured.

**Bulk notification** capabilities support administrative messaging and system-wide announcements through efficient batch processing. The system creates individual notification records while optimizing database operations and email delivery through queuing mechanisms.

#### Signal-driven automation
Automatic notification generation connects to system events through Django's signal framework, eliminating manual integration requirements across system components.

**Alert notifications** trigger automatically when new alerts are created, routing notifications to subscribed users based on geographic and topic preferences. **Task notifications** inform users of completion status for long-running operations, particularly data pipeline and analysis tasks. **System notifications** communicate maintenance schedules, configuration changes, and operational status updates.

The signal system maintains loose coupling between notification generation and triggering events, supporting system evolution without breaking notification workflows.

### 11.5 API Endpoints

#### Notification Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/notifications/` | List user's notifications |
| GET | `/api/notifications/{id}/` | Get notification details |
| POST | `/api/notifications/{id}/read/` | Mark as read |
| POST | `/api/notifications/mark-all-read/` | Mark all as read |
| DELETE | `/api/notifications/{id}/` | Delete notification |
| GET | `/api/notifications/unread-count/` | Get unread count |
| GET | `/api/notifications/preferences/` | Get user preferences |
| PUT | `/api/notifications/preferences/` | Update preferences |

#### Request/Response Examples

**List Notifications**
```http
GET /api/notifications/?type=alert&is_read=false
Authorization: Bearer {token}

Response:
{
    "count": 5,
    "next": null,
    "previous": null,
    "results": [
        {
            "id": 123,
            "type": "alert",
            "priority": "high",
            "title": "Conflict Alert - North Darfur",
            "message": "New conflict detected with high severity",
            "icon": "bi-exclamation-triangle",
            "link": "/alerts/123/",
            "is_read": false,
            "created_at": "2025-09-19T10:30:00Z",
            "data": {
                "alert_id": 456,
                "severity": "high",
                "locations": ["North Darfur"]
            }
        }
    ]
}
```

**Update Preferences**
```http
PUT /api/notifications/preferences/
Content-Type: application/json

{
    "email_enabled": true,
    "email_frequency": "daily",
    "alert_notifications": true,
    "quiet_hours_enabled": true,
    "quiet_hours_start": "22:00",
    "quiet_hours_end": "07:00"
}
```

### 11.6 Web Interface

#### Notification Center
Main interface for viewing and managing notifications.

**Features:**
- Real-time notification badge with unread count
- Dropdown panel for quick access
- Full notification center page
- Filtering by type, priority, and read status
- Bulk actions (mark all read, delete all)
- Settings panel for preferences

**UI Components:**

1. **Notification Badge** (Header)
   - Shows unread count
   - Updates in real-time
   - Click to open dropdown

2. **Notification Dropdown**
   - Last 5 unread notifications
   - Quick actions (mark read, dismiss)
   - Link to full notification center

3. **Notification Center Page**
   - Complete notification list
   - Advanced filtering
   - Search functionality
   - Pagination
   - Bulk operations

4. **Preference Settings**
   - Channel toggles
   - Type preferences
   - Frequency settings
   - Quiet hours configuration

#### JavaScript Integration

```javascript
// Real-time notification updates
class NotificationService {
    constructor() {
        this.websocket = null;
        this.unreadCount = 0;
    }

    connect() {
        this.websocket = new WebSocket('ws://localhost:8000/ws/notifications/');
        this.websocket.onmessage = this.handleMessage.bind(this);
    }

    handleMessage(event) {
        const notification = JSON.parse(event.data);
        this.showNotification(notification);
        this.updateBadge();
    }

    showNotification(notification) {
        // Show toast or browser notification
        if (Notification.permission === "granted") {
            new Notification(notification.title, {
                body: notification.message,
                icon: '/static/img/logo.png'
            });
        }
    }

    updateBadge() {
        fetch('/api/notifications/unread-count/')
            .then(response => response.json())
            .then(data => {
                document.querySelector('.notification-badge').textContent = data.count;
            });
    }
}
```

### 11.7 Email Integration

#### Email Templates
Notification emails use customizable templates stored in the database.

**Template Types:**
- Individual notification
- Daily digest
- Weekly summary
- System alerts

**Template Variables:**
- `{{ user }}` - Recipient user object
- `{{ notification }}` - Notification object
- `{{ notifications }}` - List for digests
- `{{ site_url }}` - Base URL
- `{{ unsubscribe_url }}` - Unsubscribe link

#### Email Delivery

```python
class EmailNotificationService:
    @staticmethod
    def send_immediate(notification: InternalNotification):
        """Send notification email immediately."""

    @staticmethod
    def send_daily_digest(user: User):
        """Send daily digest of notifications."""

    @staticmethod
    def send_weekly_summary(user: User):
        """Send weekly summary of activity."""
```

### 11.8 Performance Considerations

1. **Database Indexing**
   - Index on `(user, is_read, created_at)` for fast queries
   - Index on `type` and `priority` for filtering
   - Composite index for unread count queries

2. **Caching**
   - Cache unread counts (5-minute TTL)
   - Cache user preferences
   - Invalidate on updates

3. **Bulk Operations**
   - Use `bulk_create()` for mass notifications
   - Batch email sending through Celery
   - Async WebSocket notifications

4. **Data Retention**
   - Auto-delete read notifications after 30 days
   - Archive important notifications
   - Configurable retention policies

### 11.9 Security

1. **Access Control**
   - Users can only access their own notifications
   - Admin override for system notifications
   - Rate limiting on API endpoints

2. **Data Privacy**
   - Sensitive data encrypted in `data` field
   - PII removal in archived notifications
   - Audit log for admin actions

3. **Email Security**
   - SPF/DKIM configuration
   - Unsubscribe token validation
   - Rate limiting on email sends

### 11.10 Testing

#### Unit Tests
```python
class NotificationTestCase(TestCase):
    def test_create_notification(self):
        """Test notification creation."""

    def test_mark_as_read(self):
        """Test marking notification as read."""

    def test_bulk_notification(self):
        """Test sending to multiple users."""

    def test_email_delivery(self):
        """Test email sending."""
```

#### Integration Tests
- Test signal-based notification creation
- Test WebSocket delivery
- Test email template rendering
- Test preference enforcement

### 11.11 Monitoring

**Metrics to Track:**
- Notification delivery rate
- Email send success rate
- Average read time
- Unread notification backlog
- API response times

**Alerts:**
- High unread count (>100 per user)
- Email delivery failures
- WebSocket connection issues
- Database query performance
